import {
  css,
  html,
  listen,
  Connected,
  Component,
  Autonomous,
  query,
} from '@workstream/common/elements';

@Autonomous({
  selector: 'workstream-root',
  mode: 'open',
})
export class AppElement extends Component(HTMLElement) implements Connected {
  public static observed = [];

  mimeType: string;
  stream: MediaStream;
  mediaRecorder: MediaRecorder;
  recordedBlobs: Blob[] = [];

  button: Record<'play' | 'start' | 'record' | 'download', HTMLButtonElement>;
  video: Record<'recorder' | 'recorded', HTMLVideoElement>;
  link: HTMLAnchorElement;

  @query('#message')
  message: HTMLOutputElement;

  styles = css`
    :host {
      flex: 1;
      margin: 0;
      z-index: 1;
      padding: 20px;
      height: 100%;
      display: flex;
      padding: 32px;
      border-radius: 12px;
      flex-direction: column;
    }

    main {
      z-index: 2;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      width: 800px;
      margin: 0px auto;
      flex: 1;
    }

    section {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    section video {
      position: absolute;
      display: inline-flex;
      width: 100%;
      max-width: 100%;
      max-height: 460px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    section video#recorded {
      border: none;
    }

    nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 80px;
      position: relative;
    }
    nav > div {
      gap: 16px;
      display: flex;
      flex-wrap: nowrap;
      justify-content: space-between;
      align-items: center;
      flex-direction: row;
      align-content: center;
    }

    output {
      color: var(--red-05);
    }

    /* ----------------------------------------------
    * Generated by Animista on 2021-6-3 12:37:25
    * Licensed under FreeBSD License.
    * See http://animista.net/license for more info.
    * w: http://animista.net, t: @cssanimista
    * ---------------------------------------------- */

    .ping {
      -webkit-animation: ping 1s linear infinite both;
      animation: ping 1s linear infinite both;
    }
    /**
    * ----------------------------------------
    * animation ping
    * ----------------------------------------
    */
    @-webkit-keyframes ping {
      0% {
        -webkit-transform: scale(0.2);
        transform: scale(0.2);
        opacity: 0.8;
      }
      80% {
        -webkit-transform: scale(1.2);
        transform: scale(1.2);
        opacity: 0;
      }
      100% {
        -webkit-transform: scale(2.2);
        transform: scale(2.2);
        opacity: 0;
      }
    }
    @keyframes ping {
      0% {
        -webkit-transform: scale(0.2);
        transform: scale(0.2);
        opacity: 0.8;
      }
      80% {
        -webkit-transform: scale(1.2);
        transform: scale(1.2);
        opacity: 0;
      }
      100% {
        -webkit-transform: scale(2.2);
        transform: scale(2.2);
        opacity: 0;
      }
    }
  `;

  template = html`
    <!-- <main>
      <section>
        <video id="recorder" playsinline autoplay muted></video>
        <video id="recorded" playsinline loop></video>
      </section>
      <nav>
        <div>
          <button class="outlined" is="text-button" size="medium" id="start">
            <bs-icon icon="play"></bs-icon>
          </button>
          <label is="devpr-checkbox">
            <input type="checkbox" name="muted" checked />
            <span>Mute</span>
          </label>
          <button class="outlined cancel" is="text-button" id="record" disabled>
            <bs-icon icon="record"></bs-icon>
          </button>
        </div>
        <div>
          <button class="outlined" is="text-button" id="play" disabled>
            <bs-icon icon="play"></bs-icon>
          </button>
          <button class="outlined" is="text-button" id="download" disabled>
            <bs-icon icon="download"></bs-icon>
          </button>
        </div>
      </nav>
      <a id="downlink" download></a>
      <output id="message"></output>
    </main> -->
  `;

  connected() {
  }
  // connected() {
  //   this.button = {
  //     play: this.shadowRoot.querySelector('#play'),
  //     start: this.shadowRoot.querySelector('#start'),
  //     record: this.shadowRoot.querySelector('#record'),
  //     download: this.shadowRoot.querySelector('#download'),
  //   };

  //   this.video = {
  //     recorder: this.shadowRoot.querySelector('#recorder'),
  //     recorded: this.shadowRoot.querySelector('#recorded'),
  //   };

  //   this.link = this.shadowRoot.querySelector('#downlink');

  //   this.button.start.focus();
  // }

  // @listen('input', 'change', true)
  // onCheckedChange({ checked }) {
  //   console.log(checked);
  //   this.video.recorder.muted = checked;
  // }

  // @listen('#start', 'click')
  // onStart() {
  //   const constraints = { video: true, audio: true };

  //   this.init(constraints)
  //     .then((stream) => {
  //       this.stream = stream;
  //       this.button.start.disabled = true;
  //       this.button.record.disabled = false;
  //       this.video.recorder.srcObject = stream;
  //     })
  //     .then(() => this.button.record.focus());
  // }

  // @listen('#play', 'click')
  // onPlay() {
  //   const blob = new Blob(this.recordedBlobs, { type: this.mimeType });
  //   this.video.recorded.src = URL.createObjectURL(blob);
  //   this.video.recorded.controls = true;
  //   this.video.recorded.play();
  //   this.button.download.focus();
  // }

  // @listen('#record', 'click')
  // onRecord() {
  //   const { state } = this.mediaRecorder ?? {};

  //   if (state && state === 'recording') {
  //     this.mediaRecorder.stop();
  //   } else {
  //     this.startRecording();
  //   }
  // }

  // @listen('#download', 'click')
  // onDownload() {
  //   const blob = new Blob(this.recordedBlobs, { type: this.mimeType });
  //   this.link.href = URL.createObjectURL(blob);
  //   this.link.download = 'video.webm';
  //   this.link.click();
  // }

  // // Core
  // startRecording() {
  //   this.recordedBlobs = [];

  //   const mimeTypes = [
  //     'video/webm;codecs=vp9,opus',
  //     'video/webm;codecs=vp8,opus',
  //     'video/webm',
  //     'video/mp4',
  //   ];

  //   this.mimeType = mimeTypes.find((type) => {
  //     return MediaRecorder.isTypeSupported(type);
  //   });

  //   if (!this.mimeType) {
  //     console.error('MediaRecorder support');
  //   }

  //   try {
  //     this.mediaRecorder = new MediaRecorder(this.stream, {
  //       mimeType: this.mimeType,
  //     });

  //     this.mediaRecorder.ondataavailable = ({ data }: BlobEvent) => {
  //       if (data && data.size > 0) {
  //         this.recordedBlobs.push(data);
  //       }
  //     };

  //     this.mediaRecorder.start();
  //     const icon = this.button.record.querySelector('bs-icon');

  //     this.mediaRecorder.onstart = () => {
  //       // icon.setState(pause);
  //       icon.classList.add('ping');
  //     };
  //     this.mediaRecorder.onstop = () => {
  //       // icon.setState(record);
  //       icon.classList.remove('ping');

  //       this.button.play.disabled = false;
  //       this.button.download.disabled = false;

  //       this.button.play.focus();
  //     };
  //   } catch (err) {
  //     console.error('Exception while creating MediaRecorder:', err);

  //     this.message.innerHTML = `Erro ao criar objeto MediaRecorder,
  //     por favor, abra uma issue por relatando o problema usando este
  //     <a href="https://github.com/DeveloperParana/recursos/issues/new">link</a>
  //   `;
  //   }
  // }

  // async init({ video, audio }: MediaStreamConstraints) {
  //   try {
  //     const display = await this.getDisplay(video as MediaTrackConstraints);
  //     const user = await this.getUser(audio as MediaTrackConstraints);

  //     const [track] = user.getAudioTracks();
  //     display.addTrack(track);

  //     return display;
  //   } catch (err) {
  //     alert(err);
  //   }
  // }

  // getUser(audio: MediaTrackConstraints) {
  //   return navigator.mediaDevices.getUserMedia({ audio });
  // }

  // getDisplay(video: MediaTrackConstraints) {
  //   return navigator.mediaDevices.getDisplayMedia({ video });
  // }
}
